{
  "version": 3,
  "sources": ["../../assets/js/pinegeist/index.ts", "../../assets/js/pinegeist/live.ts", "../../assets/js/pinegeist/plugin.ts"],
  "sourcesContent": ["import type { LiveHelper } from \"./live\"\n\ndeclare global {\n  interface HTMLElement {\n    _lv_helper?: LiveHelper\n  }\n}\n\nexport { Hook } from \"./live\"\nexport { plugin } from \"./plugin\"\n", "type Dict = Record<string, unknown>\n\ninterface ViewHookInstance {\n  el: HTMLElement\n  handleEvent<T extends Dict>(event: string, onEvent: (payload: T) => void): () => void\n  pushEvent<T extends Dict, R extends Dict>(\n    event: string,\n    payload: T,\n    onReply?: (reply: R) => void\n  ): void\n}\n\ninterface ViewHook {\n  mounted(this: ViewHookInstance): void\n}\n\nexport class LiveHelper {\n  #viewHook: ViewHookInstance\n\n  constructor(viewHook: ViewHookInstance) {\n    this.#viewHook = viewHook\n  }\n\n  on<T extends Dict = Dict>(event: string, onEvent: (payload: T) => void) {\n    this.#viewHook.handleEvent(event, onEvent)\n  }\n\n  push<T extends Dict = Dict, R extends Dict = Dict>(\n    event: string,\n    payload: T,\n    onReply?: (reply: R) => void\n  ) {\n    this.#viewHook.pushEvent(event, payload, onReply)\n  }\n\n  exec() {\n    // TODO: implement this later\n  }\n}\n\nexport const Hook = {\n  mounted() {\n    this.el._lv_helper = new LiveHelper(this)\n  }\n} satisfies ViewHook\n", "import type { PluginCallback } from \"alpinejs\"\n\n// an object that always return a noop function when accessed\nconst noop = () => {}\nconst uninitialized = new Proxy(\n  {},\n  {\n    get() {\n      return noop\n    }\n  }\n)\n\nexport const plugin: PluginCallback = (Alpine) => {\n  Alpine.magic(\"live\", (el) => {\n    // the lv helper is initialized only after LiveView has mounted\n    // returns a noop object when LiveView is not ready\n    const root = Alpine.closestRoot(el)\n    return root?._lv_helper ?? uninitialized\n  })\n\n  Alpine.directive(\"live-on\", (el, { value, expression }, { evaluate }) => {\n    const root = Alpine.closestRoot(el)\n    if (!root || !root._lv_helper) return\n    root._lv_helper.on(value, (payload) => {\n      evaluate(expression, { scope: { $payload: payload, params: [payload] } })\n    })\n  })\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACgBO,IAAM,aAAN,MAAiB;AAAA,EACtB;AAAA,EAEA,YAAY,UAA4B;AACtC,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,GAA0B,OAAe,SAA+B;AACtE,SAAK,UAAU,YAAY,OAAO,OAAO;AAAA,EAC3C;AAAA,EAEA,KACE,OACA,SACA,SACA;AACA,SAAK,UAAU,UAAU,OAAO,SAAS,OAAO;AAAA,EAClD;AAAA,EAEA,OAAO;AAAA,EAEP;AACF;AAEO,IAAM,OAAO;AAAA,EAClB,UAAU;AACR,SAAK,GAAG,aAAa,IAAI,WAAW,IAAI;AAAA,EAC1C;AACF;;;ACzCA,IAAM,OAAO,MAAM;AAAC;AACpB,IAAM,gBAAgB,IAAI;AAAA,EACxB,CAAC;AAAA,EACD;AAAA,IACE,MAAM;AACJ,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEO,IAAM,SAAyB,CAAC,WAAW;AAChD,SAAO,MAAM,QAAQ,CAAC,OAAO;AAG3B,UAAM,OAAO,OAAO,YAAY,EAAE;AAClC,WAAO,MAAM,cAAc;AAAA,EAC7B,CAAC;AAED,SAAO,UAAU,WAAW,CAAC,IAAI,EAAE,OAAO,WAAW,GAAG,EAAE,SAAS,MAAM;AACvE,UAAM,OAAO,OAAO,YAAY,EAAE;AAClC,QAAI,CAAC,QAAQ,CAAC,KAAK;AAAY;AAC/B,SAAK,WAAW,GAAG,OAAO,CAAC,YAAY;AACrC,eAAS,YAAY,EAAE,OAAO,EAAE,UAAU,SAAS,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;AAAA,IAC1E,CAAC;AAAA,EACH,CAAC;AACH;",
  "names": []
}
