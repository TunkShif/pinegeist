{
  "version": 3,
  "sources": ["../../assets/js/pinegeist/command.ts", "../../assets/js/pinegeist/live.ts", "../../assets/js/pinegeist/plugin.ts"],
  "sourcesContent": ["import type { LiveHelper } from \"./live\"\n\ntype TransitionClasses = string | [transition: string[], start: string[], end: string[]]\n\nexport interface CommandMap {\n  add_class: {\n    names: string\n    to?: string\n    transition?: TransitionClasses\n    time?: number\n  }\n  exec: {\n    attr: string\n    to?: string\n  }\n  focus: {\n    to: string\n  }\n  focus_first: {\n    to: string\n  }\n  hide: {\n    to: string\n    transition?: TransitionClasses\n    time?: number\n  }\n  navigate: {\n    href: string\n    replace?: boolean\n  }\n  patch: {\n    href: string\n    replace?: boolean\n  }\n  pop_focus: {\n    [x: string]: never\n  }\n  push: {\n    event: string\n    value?: Record<string, unknown>\n    loading?: string\n    page_loading?: boolean\n  }\n  push_focus: {\n    to?: string\n  }\n  remove_attr: {\n    attr: string\n    to?: string\n  }\n  remove_class: {\n    names: string\n    to?: string\n    transition?: TransitionClasses\n    time?: number\n  }\n  set_attr: {\n    attr: [name: string, value: string]\n    to?: string\n  }\n  show: {\n    to?: string\n    transition?: TransitionClasses\n    time?: number\n    display?: string\n  }\n  toggle: {\n    to?: string\n    in?: TransitionClasses\n    out?: TransitionClasses\n    time?: number\n    display?: string\n  }\n  toggle_attr: {\n    attr: [name: string, val1: string, val2?: string]\n    to?: string\n  }\n  toggle_class: {\n    names: string\n    to?: string\n    transition?: TransitionClasses\n    time?: number\n  }\n  transition: {\n    transition: TransitionClasses\n    to?: string\n    time?: number\n  }\n}\n\nexport const encode = (name: string, params: Record<string, unknown>) =>\n  JSON.stringify([[name, params]])\n\nexport const createCommands = (el: HTMLElement, lv: LiveHelper) =>\n  new Proxy(\n    {},\n    {\n      get(_target, name) {\n        return (params: Record<string, unknown> = {}) =>\n          lv.exec(el, name as keyof CommandMap, params)\n      }\n    }\n  )\n", "import type { LiveSocket } from \"phoenix_live_view\"\nimport { encode, type CommandMap } from \"./command\"\n\ntype Dict = Record<string, unknown>\n\ninterface ViewHookInstance {\n  el: HTMLElement\n  liveSocket: LiveSocket\n  handleEvent<T extends Dict>(event: string, onEvent: (payload: T) => void): () => void\n  pushEvent<T extends Dict, R extends Dict>(\n    event: string,\n    payload: T,\n    onReply?: (reply: R) => void\n  ): void\n}\n\ninterface ViewHook {\n  mounted(this: ViewHookInstance): void\n}\n\nexport class LiveHelper {\n  #viewHook: ViewHookInstance\n\n  constructor(viewHook: ViewHookInstance) {\n    this.#viewHook = viewHook\n  }\n\n  on<T extends Dict = Dict>(event: string, onEvent: (payload: T) => void) {\n    this.#viewHook.handleEvent(event, onEvent)\n  }\n\n  push<T extends Dict = Dict, R extends Dict = Dict>(\n    event: string,\n    payload: T,\n    onReply?: (reply: R) => void\n  ) {\n    this.#viewHook.pushEvent(event, payload, onReply)\n  }\n\n  exec<TName extends keyof CommandMap>(el: HTMLElement, name: TName, params: CommandMap[TName]) {\n    this.#viewHook.liveSocket.execJS(el, encode(name, params))\n  }\n}\n\nexport const Hook = {\n  mounted() {\n    this.el._lv_helper = new LiveHelper(this)\n  }\n} satisfies ViewHook\n", "import type { PluginCallback } from \"alpinejs\"\nimport { createCommands } from \"./command\"\nimport type { LiveHelper } from \"./live\"\n\n// an object that always return a noop function when accessed\n// the lv helper is initialized only after LiveView has mounted\n// returns a noop object when LiveView is not ready\nconst noop = () => {}\nconst uninitialized = new Proxy(\n  {},\n  {\n    get() {\n      return noop\n    }\n  }\n) as LiveHelper\n\nexport const plugin: PluginCallback = (Alpine) => {\n  Alpine.magic(\"live\", (el) => {\n    const root = Alpine.closestRoot(el)\n    return root?._lv_helper ?? uninitialized\n  })\n\n  Alpine.magic(\"js\", (el) => {\n    const root = Alpine.closestRoot(el)\n    const lv = root?._lv_helper ?? uninitialized\n    return lv === uninitialized ? lv : createCommands(el, lv)\n  })\n\n  Alpine.directive(\"live-on\", (el, { value, expression }, { evaluate }) => {\n    const root = Alpine.closestRoot(el)\n    if (!root || !root._lv_helper) return\n    root._lv_helper.on(value, (payload) => {\n      evaluate(expression, { scope: { $payload: payload, params: [payload] } })\n    })\n  })\n}\n"],
  "mappings": ";AA0FO,IAAM,SAAS,CAAC,MAAc,WACnC,KAAK,UAAU,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC;AAE1B,IAAM,iBAAiB,CAAC,IAAiB,OAC9C,IAAI;AAAA,EACF,CAAC;AAAA,EACD;AAAA,IACE,IAAI,SAAS,MAAM;AACjB,aAAO,CAAC,SAAkC,CAAC,MACzC,GAAG,KAAK,IAAI,MAA0B,MAAM;AAAA,IAChD;AAAA,EACF;AACF;;;AClFK,IAAM,aAAN,MAAiB;AAAA,EACtB;AAAA,EAEA,YAAY,UAA4B;AACtC,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,GAA0B,OAAe,SAA+B;AACtE,SAAK,UAAU,YAAY,OAAO,OAAO;AAAA,EAC3C;AAAA,EAEA,KACE,OACA,SACA,SACA;AACA,SAAK,UAAU,UAAU,OAAO,SAAS,OAAO;AAAA,EAClD;AAAA,EAEA,KAAqC,IAAiB,MAAa,QAA2B;AAC5F,SAAK,UAAU,WAAW,OAAO,IAAI,OAAO,MAAM,MAAM,CAAC;AAAA,EAC3D;AACF;AAEO,IAAM,OAAO;AAAA,EAClB,UAAU;AACR,SAAK,GAAG,aAAa,IAAI,WAAW,IAAI;AAAA,EAC1C;AACF;;;ACzCA,IAAM,OAAO,MAAM;AAAC;AACpB,IAAM,gBAAgB,IAAI;AAAA,EACxB,CAAC;AAAA,EACD;AAAA,IACE,MAAM;AACJ,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEO,IAAM,SAAyB,CAAC,WAAW;AAChD,SAAO,MAAM,QAAQ,CAAC,OAAO;AAC3B,UAAM,OAAO,OAAO,YAAY,EAAE;AAClC,WAAO,MAAM,cAAc;AAAA,EAC7B,CAAC;AAED,SAAO,MAAM,MAAM,CAAC,OAAO;AACzB,UAAM,OAAO,OAAO,YAAY,EAAE;AAClC,UAAM,KAAK,MAAM,cAAc;AAC/B,WAAO,OAAO,gBAAgB,KAAK,eAAe,IAAI,EAAE;AAAA,EAC1D,CAAC;AAED,SAAO,UAAU,WAAW,CAAC,IAAI,EAAE,OAAO,WAAW,GAAG,EAAE,SAAS,MAAM;AACvE,UAAM,OAAO,OAAO,YAAY,EAAE;AAClC,QAAI,CAAC,QAAQ,CAAC,KAAK;AAAY;AAC/B,SAAK,WAAW,GAAG,OAAO,CAAC,YAAY;AACrC,eAAS,YAAY,EAAE,OAAO,EAAE,UAAU,SAAS,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;AAAA,IAC1E,CAAC;AAAA,EACH,CAAC;AACH;",
  "names": []
}
